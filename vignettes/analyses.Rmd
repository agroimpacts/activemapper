# Analyses and figures
## Datasets

```{r setup, include=FALSE, cache=FALSE, message = FALSE}
library(raster)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(rmapaccuracy)
library(here)
library(doMC)
library(activemapper)
library(aws.s3)
```

### Base Datasets

The pre-preparation of base datasets that install with the `activemapper` package is shown in `external/scripts/data_setup.R`. These are loaded in here. 

```{r, eval=FALSE}
res <- 0.005
res_supergrid <- 1
num_supergrid <- res_supergrid / res

mgrid <- raster(
  system.file("extdata/ghana_grid.tif", package = "activemapper")
)
africa <- st_read(
  system.file("extdata/africa.geojson", package = "activemapper")
)
africa_cont <- africa %>% st_union %>% st_sf
ghana <- africa %>% filter(name == "Ghana") %>% select(geometry)

degrees <- st_read(
  system.file("extdata/degrees.geojson", package = "activemapper")
)
tiles <- st_read(
  system.file("extdata/ghana_tiles.geojson", package = "activemapper")
) 
aois <- st_read(
  system.file("extdata/aois.geojson", package = "activemapper")
)
# ggplot(data = tiles) + 
#   geom_sf(aes(fill = as.factor(aoi1)), col = "transparent")
```

### Map results
```{r, eval=FALSE}
## segments
segment_files <- dir(here("external/data/results/segments/merged"), 
                     pattern = "boundarymerge", full.names = TRUE)

iid <- as.numeric(gsub("[[:alpha:]]|_|\\.", "", basename(segment_files)))
segment_files <- tibble(file = segment_files, order = iid) %>% arrange(iid)
```

## Intermediate processing
### Grid for stratifying model results
```{r, eval=FALSE}
r <- raster(extent(tiles), res = 0.05)
crs(r) <- crs(tiles)

# for field areas
tilesr <- fasterize::fasterize(tiles, r, field = "aoi1")
tilesr005 <- disaggregate(tilesr, fact = 10)
tilesr005_sf <- stars::st_as_stars(tilesr005) %>% st_as_sf() %>% 
  rename(aoi1 = layer)

# for point intersection
# mask main grid and convert to points
mgrid <- mask(mgrid, tiles)
mgrid_xy <- as.data.frame(mgrid, xy = TRUE) %>% 
  st_as_sf(coords = c("x", "y"), crs = 4326) %>% rename(id = ghana_grid) %>% 
  tidyr::drop_na(id)

# join with tiles
# system.time(extract(tilesr, master_grid_xy))  # 11.81
system.time(mgrid_xytiles <- st_join(mgrid_xy, tilesr005_sf))  # 26

# ggplot(tilesr005_sf) + geom_sf(aes(fill = layer), col = "transparent")
# tilesr005_sf %>% filter(layer == 1) %>% plot()
# tiles_ss <- tiles %>% filter(aoi1 == 1) %>% slice(1:6, 10:15)
# tiles_ss <- tiles %>% filter(aoi1 == 1) %>% slice(1)
# plot(st_geometry(tiles_ss))
# plot(crop(tilesr, tiles_ss), add = TRUE)
# plot(crop(tilesr005, tiles_ss), add = TRUE)
# plot(crop(master_grid, tiles_ss), add = TRUE)
# plot(master_grid)

```

### Field characteristics
#### Field density

Process the field segments to calculate cropland coverage per 0.005 degree pixel. Run these in loop.

```{r, eval=FALSE}
logf <- here("external/logs/gridding_005.log")
registerDoMC(cores = 7)
fareas <- foreach(i = segment_files$order, .combine = stack) %dopar% {  
  # i <- segment_files[11]
  aoi_id <- gsub("[[:alpha:]]|_|\\.", "", basename(i))
  
  cat(glue::glue("Starting {aoi_id} at {Sys.time()}"), file = logf, 
      sep = "\n", append = TRUE)
  print(aoi_id)
  
  # read in fields
  cat(glue::glue("...aoi {aoi_id} reading in fields and calculating tile area"),
      file = logf, sep = "\n", append = TRUE)
  flds <- read_sf(i)
  # select out AOI grid and 
  aoi_tiles <- tilesr005_sf %>% filter(aoi1 == aoi_id) %>% 
    mutate(cid = 1:n(), area = as.numeric(st_area(.) / 10000))

  # intersect fields
  cat(glue::glue("...aoi {aoi_id} intersecting fields and calculating area"),
      file = logf, sep = "\n", append = TRUE)
  # fld_int <- st_intersection(aoi_tiles, flds)
  fld_int <- st_join(aoi_tiles_xy, flds)
  fld_int %>% mutate(class = )

  drops <- fld_int %>%
    st_is(c("POINT", "MULTIPOINT", "LINESTRING", "MULTILINESTRING")) %>%
    which()
  polys <- fld_int %>% st_is("POLYGON") %>% which()
  fld_int <- fld_int %>% slice(-drops)
  fld_int <- fld_int %>% mutate(farea = as.numeric(st_area(.) / 10000))
  fld_areas <- fld_int %>% as_tibble() %>% group_by(cid) %>%
    summarize(farea = sum(farea))
  
  cat(glue::glue("...aoi {aoi_id} joining areas with tiles"), file = logf,
      sep = "\n", append = TRUE)
  aoi_tiles <- left_join(aoi_tiles, fld_areas) %>%
    mutate(farea = ifelse(is.na(farea), 0, farea)) %>%
    mutate(fprop = round(farea / area, 4))
  
  # crop down to just 
  cat(glue::glue("...aoi {aoi_id} rasterizing"), file = logf, sep = "\n",
      append = TRUE)
  aoir <- tilesr005 == as.numeric(aoi_id)
  arear <- area(aoir) * 100
  # aoir[aoir == 0] <- NA
  farea <- fasterize::fasterize(aoi_tiles, aoir, field = "fprop",
                                fun = "sum", background = 0)
  
  cat(glue::glue("Finished aoi {aoi_id} at {Sys.time()}"), file = logf,
      sep = "\n", append = TRUE)
  cat("", file = logf, sep = "\n", append = TRUE)
  return(farea)
}

# plot(fdensity)

# writeRaster(fdensity, filename = here("external/data/field_density005.tif"))
# fdensity <- raster(here("external/data/field_density005.tif"))
```

#### Field points
For reference site selection and stratification
```{r, eval=FALSE}
logf <- here("external/logs/field_points_005.log")
registerDoMC(cores = 7)
fpoints <- foreach(i = segment_files$file) %dopar% {  
  # i <- segment_files$file[1]
  aoi_id <- gsub("[[:alpha:]]|_|\\.", "", basename(i))
  
  cat(glue::glue("Starting {aoi_id} at {Sys.time()}"), file = logf, 
      sep = "\n", append = TRUE)

  # read in fields
  cat(glue::glue("...aoi {aoi_id} reading in fields and calculating tile area"),
      file = logf, sep = "\n", append = TRUE)
  flds <- read_sf(i) %>% rename(fid = id)  # rename id field

  # intersect fields with main grid
  cat(glue::glue("...aoi {aoi_id} intersecting fields and calculating area"),
      file = logf, sep = "\n", append = TRUE)
  mgrid_ss <- mgrid_xytiles %>% filter(aoi1 == aoi_id)  # subset mgrid
  fld_int <- st_join(mgrid_ss, flds)
  fld_int <- fld_int %>% mutate(class = ifelse(is.na(fid), 0, 1)) %>% 
    select(id, fid, aoi1, class) %>% rename(aoi = aoi1)
  
  cat(glue::glue("aoi {aoi_id} complete"),
      file = logf, sep = "\n", append = TRUE)
  return(fld_int)
}

# Rename one of two AOI3 results, and then bind
fpoints[[3]] <- fpoints[[3]] %>% mutate(aoi = "3N")
fpoints <- do.call(rbind, fpoints)
xy <- fpoints %>% st_coordinates() %>% as_tibble() %>% rename(x = X, y = Y)
fpoints_tb <- bind_cols(fpoints %>% as_tibble() %>% select(-geometry), xy)
# data.table::fwrite(
#   fpoints_tb, file = here("external/data/field_points005.csv")
# )

# readr::read_csv(here("external/data/field_points005.csv"))
# fpoints[[3]] %>% filter(class == 1) %>% st_geometry %>% plot(cex = 0.1, pch = 16)
```


## Climatology (supplemental)
Grab CHIRPs monthly data from `mapper`
```{r, eval = FALSE}
library(stars)
dir(file.path(data_path, "external/climatology/chirps"), full.names = TRUE) %>% 
  stack(.) %>% crop(., ghana) -> chirps
rftot <- calc(chirps, sum)
monthly_pct <- chirps / rftot * 100
names(monthly_pct) <- lubridate::month(1:12, label = TRUE)
monthly_pct <- setZ(monthly_pct, lubridate::month(1:12, label = TRUE))
monthly_pct_stars <- stars::st_as_stars(monthly_pct)

# plot(monthly_pct_stars, breaks = seq(0, 35), ) + 
#   geom_sf(data = ghana, fill = "transparent", size = 0.3)
p <- ggplot() + geom_stars(data = monthly_pct_stars) + 
  facet_wrap("band", nrow = 2) + 
  geom_sf(data = ghana, fill = "transparent", size = 0.3) +
  scale_fill_viridis_c(breaks = seq(0, 35, 5), "%", na.value = "grey90") +
  xlab("") + ylab("") + ggtitle("Percent of annual rainfall by month") + 
  theme(panel.background = element_rect(fill = NA), 
        axis.text = element_blank(), axis.ticks = element_blank()) 
ggsave("manuscript/figures/si_rainfall_pct.png", height = 4, width = 6, 
       units = "in", dpi = 300)
```

### Mapping AOIs

These were defined in `data_prep.R`.

## Average quality of image tiles
Visually analyzed on instance `labellertest`. 



### Accuracy within blocks

Placeholder. Use imagined accuracy based on rainfall, using dummy approach as with Figure 3.  This will be replaced by metrics from tables for each instance. 
```{r, eval=FALSE}
rf <- aois %>% st_centroid %>% extract(rftot, .)
aois <- aois %>% mutate(rf = rf)

# Rainfall-accuracy relationship
rflm <- coef(lm(c(0.9, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(7) 
aois <- aois %>% 
  mutate(Accuracy = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100)

# Users
rflm <- coef(lm(c(0.85, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(1) 
aois <- aois %>% 
  mutate(User = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100)

# Producers
rflm <- coef(lm(c(0.9, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(2) 
aois <- aois %>% 
  mutate(Producer = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100) %>% 
  select(grp, aois, rf, Accuracy, User, Producer)

```

## Figure 5
Plot of Zones and average accuracy
```{r, eval = FALSE}
# ghana_tilesr %>% group_by(aoi) %>% summarize(aois = mean(aoi)) %>% ungroup %>% 
#   ggplot() + geom_sf(col = "grey70") +
#   geom_sf_text(aes(label = aoi), size = 2) + 
#   geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + 
#   theme_void()

cols <- RColorBrewer::brewer.pal(n = 9, "RdYlGn") %>% #[c(1, 9)] %>% 
  colorRampPalette(colors = .)
# RColorBrewer::display.brewer.all()

# ggsave("manuscript/figures/si_mapping_blocks.png", width = 5, height = 5, 
#        units = "in", dpi = 300)

col_grad <- scale_fill_gradientn(colors = cols(10), limits = c(70, 100), 
                                 breaks = seq(70, 100, 5)) 
p <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = Accuracy)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()
p2 <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = User)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()
p3 <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = Producer)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()

leg <- cowplot::get_legend(p + theme(legend.position = c(0.6, 1)))
gleg <- cowplot::plot_grid(NULL, leg, ncol = 1, align = "h")
gp <- cowplot::plot_grid(p + theme(legend.position = 'none'), 
                         p2 + theme(legend.position = 'none'), 
                         p3 + theme(legend.position = 'none'), nrow = 1, 
                         labels = c("Overall", "User's", "Producer's"), 
                         label_x = 0.0)
gall <- cowplot::plot_grid(gp, gleg, rel_widths = c(1, 0.1), label_x = 0)
# gall

ggsave("manuscript/figures/figure5.png", width = 9, 
       height = 4, units = "in", dpi = 300)

```

## Figure 6: High, low, medium comparisons

Statistics from high, medium, low experiment results from Boka. 
```{r, eval = FALSE}
library(tidyr)
library(dplyr)
library(ggplot2)
library(cowplot)

# metrics
scores <- tibble(
  # AOI = as.character(c(rep(1, 3), rep(8, 3), rep(15, 3))), 
  AOI = c(rep(1, 3), rep(8, 3), rep(15, 3)), 
  Label = c("Low", "High", "Consensus", "Low", "High", "Consensus", 
            "Low", "High", "Consensus"), 
  AUC = c(0.6987, 0.7803, 0.7741, 0.7333, 0.8461, 0.8563, 0.6916, 0.7628, 
          0.7714),
  Accuracy = c(0.6575, 0.7919, 0.7897, 0.5313, 0.8361, 0.8421, 0.6279, 0.6916,
               0.7245),
  TSS = c(0.2940, 0.4194, 0.4138, 0.2568, 0.5390, 0.5639, 0.2718, 0.3835, 
          0.3916)
)
p <- scores %>% pivot_longer(cols = c("AUC", "Accuracy", "TSS")) %>% 
  arrange(AOI) %>%
  group_by(AOI) %>% 
  ggplot(.) + geom_bar(aes(x = name, y = value, fill = Label), 
                       stat = "identity", position = "dodge") + 
  scale_fill_manual(values = c("blue", "purple", "orange"), 
                    name = "Labelling strategy", 
                    labels = c("Consensus", "Highest scorer", 
                               "Lowest scorer")) + 
  xlab("Metric") + ylab("Score") + ggtitle("AOI") +
  facet_grid(. ~ AOI) + theme_cowplot() 
ggsave(p, 
       filename = here::here("manuscript/figures/figure6.png"),
       height = 4, width = 8, dpi = 300)
save(scores, file = here::here("external/data/label_experiment_metrics.rda"))
```

### Figure SX: SI probability images
```{r, eval=FALSE}
library(raster)
probpal <- viridis::viridis
cprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "1_whole/image_c294_r532.tif"))
hprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "test_byScore/aoi1/high/image_c294_r532.tif"))
lprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "test_byScore/aoi1/low/image_c294_r532.tif"))
png(here::here("manuscript/figures/si_hml_probs.png"), height = 2.65,
    width = 9.2, res = 300, units = "in", bg = "transparent")
par(mfrow = c(1, 3), mar = c(0, 0, 0, 1), oma = c(0, 0, 0, 2))
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Consensus labels", 
     cex.main = 2)
plot(cprob, lty = 0, add = TRUE, legend = FALSE, zlim = c(0, 100),
     col = probpal(20))
mtext("A", side = 3, line = -2, adj = 0.00)
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Highest scorer", 
     cex.main = 2)
mtext("B", side = 3, line = -2, adj = 0.0)
plot(hprob, lty = 0, add = TRUE, legend = FALSE, zlim = c(0, 100),
     col = probpal(20))
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Lowest scorer", 
     cex.main = 2)
mtext("C", side = 3, line = -2, adj = 0.0)
plot(lprob, lty = 0, add = TRUE, zlim = c(0, 100),
     legend.width = 1, legend.shrink = 0.5, col = probpal(20),
     legend.args = list(text = '%', side = 3, cex = 0.8))
dev.off()

```


## Consensus maps
```{r, eval=FALSE}
library(rmapaccuracy)
library(leaflet)

instance <- "mapper0"
dbase <- "Africa"
host <- paste0(instance, ".crowdmapper.org")
upw <- list("user" = "postgis", "password" = "P0stG1S")
coninfo <- mapper_connect(host)
con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), host = host,
                      dbname = "Africa", user = upw$user,
                      password = upw$password)

# coninfo <- mapper_connect(host = host)
coninfo$con <- con

common_path <- "~/Dropbox/projects/activelearning/mapper"
common_path <- file.path(common_path, "common")
params <- yaml::yaml.load_file(file.path(common_path, 'config.yaml'))

name <- "GH0431618"#"GH0448854"
sqls <- paste0("select id from master_grid where name='", name, "'")
cid <- DBI::dbGetQuery(con, sqls)[[1]]


user.sql <- paste0("select name, category, worker_id, geom_clean ",
                   "FROM user_maps INNER JOIN categories USING (category)",
                   "INNER JOIN assignment_data USING (assignment_id)",
                   " where name like '",  name, "%' ",
                   "AND categ_group ='field'")

user.polys <- DBI::dbGetQuery(con, gsub(", geom_clean", "", user.sql))
user.polys <- suppressWarnings(st_read(con, query = user.sql))
user.polys <- user.polys %>% filter(st_is(. , "POLYGON"))

# # calling consensus map manually, line by line in script
kmlid <- name
qsite <- FALSE
mode <- "consensus"

# execute consensus script
source(file.path(here::here(), "external/scripts/consensus_labels.R"))
l <- list(user.polys["worker_id"], bayesoutput[[2]], bayesoutput[[1]])
save(l, file = file.path(here::here(), "data/consensus.rda"))

scenes <- tbl(con, "scenes_data") %>% filter(cell_id == cid) %>% 
  dplyr::select(scene_id, cell_id, url, season, tms_url) %>% collect()
# scenes$scene_id

gcs <- "+proj=longlat +datum=WGS84 +no_defs"
name <- tbl(coninfo$con, "master_grid") %>% filter(id == cid) %>%
  dplyr::select(id, name, x, y) %>% collect()
gpoly <- rmapaccuracy::point_to_gridpoly(data.table::data.table(name), 
                                         w = 0.005 / 2, gcs, gcs)

s3url <- scenes %>% filter(season == "GS") %>% pull(url)
planet_path <- file.path("/vsis3", gsub("s3://", "", s3url)) 
planet <- brick(planet_path)

crfeat <- as(extend(extent(as_Spatial(ejura_sites[1, ])), 0.005),
             "SpatialPolygons")
zoomfeat <- as(extend(extent(as_Spatial(ejura_sites[1, ])), 0.002),
               "SpatialPolygons")
proj4string(crfeat) <- proj4string(as_Spatial(user.polys))
proj4string(zoomfeat) <- proj4string(as_Spatial(user.polys))
crfeat_utm <- spTransform(crfeat, crs(planet))
zoomfeat_utm <- spTransform(zoomfeat, crs(planet))
planet_cr <- crop(planet, crfeat_utm)
planet_cr2 <- crop(planet2, crfeat_utm)



# set up display
os <- (scenes %>% filter(season == "OS") %>% filter(row_number() == 1) %>% 
  dplyr::select(tms_url))$tms_url
gs <- (scenes %>% filter(season == "GS") %>% filter(row_number() == 1) %>% 
         dplyr::select(tms_url))$tms_url

m <- leaflet() %>% addTiles() %>% setView(name$x, name$y, zoom = 14) %>% 
  addTiles(os, group = "OS") %>% addTiles(gs, group = "GS") %>% 
  addPolygons(data = gpoly, fill = FALSE, group = "Cell") %>% 
  addLayersControl(overlayGroups = c("Cell", "GS", "OS"),
    options = layersControlOptions(collapsed = FALSE, autoZIndex = FALSE))
m


```

