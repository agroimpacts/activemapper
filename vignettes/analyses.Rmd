
# Analyses and figures
## Datasets

The pre-preparation of base datasets that install with the `activemapper` package is shown in `external/scripts/data_setup.R`. These are loaded in here. 

```{r, eval=FALSE}
library(raster)
library(sf)
library(dplyr)
library(ggplot2)
library(purrr)
library(rmapaccuracy)
library(here)
library(activemapper)

res <- 0.005
res_supergrid <- 1
num_supergrid <- res_supergrid / res

master_grid <- raster(system.file("extdata/ghana_grid.tif", 
                                  package = "activemapper"))
africa <- st_read(system.file("extdata/africa.geojson", 
                              package = "activemapper"))
africa_cont <- africa %>% st_union %>% st_sf
ghana <- africa %>% filter(name == "Ghana") %>% select(geometry)

tiles <- st_read(system.file("extdata/ghana_tiles.geojson", 
                             package = "activemapper")) 
degrees <- st_read(system.file("extdata/degrees.geojson", 
                               package = "activemapper")) 
```

### Figure 2: Grid System

```{r, eval = FALSE}
ghana_aois <- tiles %>% pull(aoi) %>% unique

ind <- 26  # index of selected AOI for plotting (from ghana_aois)
xylims <- st_coordinates(ghana)
maprange <-  c(range(xylims[, 1]), range(xylims[, 2]))

p1 <- ggplot(africa) + geom_sf(fill = "gray97", color = "grey", size = 0.25) +
  geom_sf(data = ghana, fill = "grey85", col = "grey", size = 0.3) +
  geom_sf(data = degrees %>% filter(grid %in% ghana_aois),
          fill = "transparent", size = 0.3) +
  geom_sf(data = degrees %>% filter(grid == ghana_aois[ind]), fill = "gray70",
          size = 0.3) +
  coord_sf(xlim = maprange[1:2], ylim = maprange[3:4]) +
  theme_void()
# p1

xylims <- degrees %>% filter(grid %in% ghana_aois[c(ind:27, 31:32)]) %>%
  st_coordinates(.)
maprange <-  c(range(xylims[, 1]), range(xylims[, 2]))

tile_sel <- tiles %>% filter(aoi == ghana_aois[ind])  # selected tile
p2 <- ggplot(ghana) + geom_sf(fill = "grey85", col = "grey") +
  geom_sf(data = degrees, fill = "transparent", size = 0.3) +
  geom_sf(data = tile_sel, fill = "gray70", size = 0.3) +
  geom_sf(data = tile_sel %>% slice(1), fill = "red3", size = 0.3) +
  coord_sf(xlim = maprange[1:2], ylim = maprange[3:4]) +
  theme_void()
# p2

gpols <- crop(master_grid, tile_sel[1, ]) %>% rasterToPolygons(.) %>%
  st_as_sf %>% st_sf(crs = 4326)
p3 <- ggplot(tile_sel %>% slice(c(1:2, 21:22))) +
  geom_sf(fill = "grey80", size = 0.3) +
  # geom_sf(data = super_cellsr %>% slice(ints[1]), fill = "grey60") +
  geom_sf(data = gpols, fill = "red3", size = 0.3) +
  theme_void()
# p3

g <- cowplot::plot_grid(p1, p2, p3, nrow = 1, scale = c(1, 1, 0.7), 
                        labels = LETTERS[1:3], label_x = 0.05)
ggsave("manuscript/figures/figure2.png", width = 7, height = 3, 
       units = "in", dpi = 300)

```

## Climatology figure (supplemental)

Grab CHIRPs monthly data from `mapper`
```{r, eval = FALSE}
library(stars)
dir(file.path(data_path, "external/climatology/chirps"), full.names = TRUE) %>% 
  stack(.) %>% crop(., ghana) -> chirps
rftot <- calc(chirps, sum)
monthly_pct <- chirps / rftot * 100
names(monthly_pct) <- lubridate::month(1:12, label = TRUE)
monthly_pct <- setZ(monthly_pct, lubridate::month(1:12, label = TRUE))
monthly_pct_stars <- stars::st_as_stars(monthly_pct)

# plot(monthly_pct_stars, breaks = seq(0, 35), ) + 
#   geom_sf(data = ghana, fill = "transparent", size = 0.3)
p <- ggplot() + geom_stars(data = monthly_pct_stars) + 
  facet_wrap("band", nrow = 2) + 
  geom_sf(data = ghana, fill = "transparent", size = 0.3) +
  scale_fill_viridis_c(breaks = seq(0, 35, 5), "%", na.value = "grey90") +
  xlab("") + ylab("") + ggtitle("Percent of annual rainfall by month") + 
  theme(panel.background = element_rect(fill = NA), 
        axis.text = element_blank(), axis.ticks = element_blank()) 
ggsave("manuscript/figures/si_rainfall_pct.png", height = 4, width = 6, 
       units = "in", dpi = 300)
```

### Mapping AOIs

These were defined in `data_setup.R`.

## Map reference selection
A random draw of cells within each map AOI, scaled proportionally from 120 to the total area of each cell.

```{r, eval = FALSE}
# set up reference proportion
aois <- aois %>% mutate(nref = ceiling(area / max(area) * 120)) %>% 
  select(aois, area, nref)

# extract cell ids for each AOI
ref_sites <- lapply(1:nrow(aois), function(x) {  # x <- 15
  print(x)
  cells <- extract(master_grid, aois[x, ])[[1]]
  return(cells[!is.na(cells)])
})
# length(which(is.na(cells)))

# sample cell ids in proportion for each AOI
set.seed(1)
ref_sites_sample <- lapply(1:length(ref_sites), function(x) {
  sn <- aois[x, ] %>% pull(nref)
  rsites <- ref_sites[[x]]
  sample(x = ref_sites[[x]], size = sn, replace = FALSE)
}) 

# and select cell coordinates from database
pw <- "password"  ####### BFG here
con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), 
                      host = "labeller1.crowdmapper.org", dbname = "Africa", 
                      user = "postgis", password = pw)

xys <- lapply(1:length(ref_sites_sample), function(x) {
  print(x)
  rsites <- ref_sites_sample[[x]]
  xy <- tbl(con, "master_grid") %>% filter(id %in% rsites) %>% 
    select(id, name, x, y) %>% collect()
})
DBI::dbDisconnect(con)

# convert to polygons
gcs <- unname(unlist(st_crs(ghana))[2])
xypolys <- lapply(1:length(xys), function(x) {
  print(x)
  polys <- point_to_gridpoly(data.table::data.table(xys[[x]]), 
                             w = 0.005 / 2, gcs, gcs)
  polys %>% mutate(aoi = x) %>% select(name, aoi)
})
ref_sites_polys <- reduce(xypolys, rbind)

# ggplot(aois) + geom_sf() + 
#   geom_sf(data = ref_sites_polys, aes(color = factor(aoi))) + theme_void()
st_write(ref_sites_polys, dsn = here("external/data/ref_samples.sqlite"),
         delete_layer = TRUE)
ref_sites_tiles <- st_intersection(ref_sites_polys %>% st_centroid, 
                                   tiles %>% select(tile))
ref_sites_tiles <- ref_sites_tiles %>% as_tibble %>% select(name, tile, aoi) %>% 
  arrange(aoi, name)
readr::write_csv(ref_sites_tiles, 
                 path = here("external/data/ref_samples_tiles.csv"))

# check also if sampled cells aren't in training or validation samples
ref_in_train <- lapply(c(1:9, 12, 15), function(x) {  # x <- 2
  ref_names <- ref_sites_tiles %>% filter(aoi == x) %>% pull(name)
  con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), dbname = "Africa", 
                        host = paste0("labeller", x, ".crowdmapper.org"), 
                        user = "postgis", password = pw)
  incoming <- tbl(con, "incoming_names") %>% select(name) %>% collect() %>% pull
  qnames <- tbl(con, "kml_data") %>% filter(kml_type == "Q") %>% 
    select(name) %>% collect %>% pull
  DBI::dbDisconnect(con)
  return(ref_names[which(ref_names %in% c(incoming, qnames))])
})

# and drop any that are
ref_sites_tiles2 <- ref_sites_tiles %>% filter(!name %in% unlist(ref_in_train))
readr::write_csv(ref_sites_tiles, 
                 path = here("external/data/ref_samples_tiles2.csv"))

# ref_sites_tiles2 %>% group_by(aoi) %>% count

# select PlanetScope data
planet <- lapply(1:6, function(x) {  # x <- 1
  cid <- ref_sites_sample[[x]]
  con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), dbname = "Africa", 
                        host = paste0("labeller", x, ".crowdmapper.org"), 
                        user = "postgis", password = pw)
  pdata <- tbl(con, "scenes_data") %>% 
    filter(cell_id %in% cid) %>% 
    select(cell_id, url, season) %>% collect()
  DBI::dbDisconnect(con)
  pdata %>% arrange(season, cell_id) %>% mutate(aoi = x) %>% 
    rename(id = cell_id) %>% select(id, aoi, season, url)
})
pth <- here::here(paste0("external/data/aoi", x, ".csv"))
readr::write_csv(planet[[1]], path = pth)
```

### Starter polygons

Version 1 creates three sets of polygons per AOI.
Create starter reference polygons for AOIs. These are fixed size in random placement in each cell. These can be moved more easily to capture pure classes
```{r, eval=FALSE}
# read back in ref sample points and create three random points in each per AOI
ref_sites_polys <- st_read(here("external/data/ref_samples.sqlite"))
set.seed(1)
ref_start_pts <- lapply(1:16, function(x) {
  print(x)
  start_pts <- suppressMessages(
    ref_sites_polys %>% filter(aoi == x) %>% 
      st_sample(size = rep(3, nrow(.)), silent = TRUE)
  )
  start_pts <- st_intersection(st_sf(start_pts), ref_sites_polys)
  xy <- start_pts %>% st_coordinates %>% as_tibble() %>% setNames(c("x", "y"))
  start_pts <- bind_cols(start_pts %>% as_tibble, xy) %>% select(name, x, y) %>%     data.table::data.table()
})

# ref_sites_polys %>% slice(2) %>% st_geometry() %>% plot
# plot(ref_start_pts_aoi1, add = TRUE)

# pick up names via intersection and convert to x, y points for use with 
# point_to_grid_poly

# create polygons from starter points, add class fields, etc. 
gcs <- unname(unlist(st_crs(tiles)))[2]
w <- 0.0001433
strt_pol_aoi1 <- point_to_gridpoly(ref_start_pts[[1]], w = w, gcs, gcs) %>% 
  group_by(name) %>% mutate(rid = 1:n()) %>% ungroup %>% mutate(class = NA) %>% 
  select(name, rid, class)
# strt_pol_aoi16 <- point_to_gridpoly(ref_start_pts[[16]], w = w, gcs, gcs) %>% 
#   group_by(name) %>% mutate(rid = 1:n()) %>% ungroup %>% 
#   mutate(class = NA) %>% select(name, rid, class)
# ref_sites_polys %>% slice(1) %>% st_geometry %>% plot
# plot(start_pols_aoi1[1:3, ], add = TRUE)

# check areas
# start_pols_aoi1 %>% st_area %>% mean
# start_pols_aoi16 %>% st_area %>% mean
st_write(strt_pol_aoi1, 
         dsn = here::here("external/data/ref_polys_ao1.sqlite"))
```

Grab necessary imagery off of S3
```{r, eval=FALSE}
library(aws.s3)
planet_aoi1 <- readr::read_csv(here::here("external/data/aoi1.csv"))
dnames <- here::here("external/data/imagery", c("GS", "OS"))
for(i in dnames) if(!dir.exists(i)) dir.create(i)

os <- get_bucket_df(bucket = "activemapper", 
                    prefix = "planet/composite_sr_buf/OS")

# os %>% select(Key, Size) %>% mutate(Size = as.numeric(Size)) %>% 
#   filter(Key %in% gsub("s3://activemapper/", "", planet_aoi1$url)) %>% 
#   summarize(sum(Size)) / 1e+9

os_urls <- planet_aoi1 %>% filter(season == "OS") %>% distinct(url) %>% 
  unname %>% unlist
for(i in os_urls[-length(os_urls)]) {
# for(i in os_urls) {  
  cmd <- paste("aws s3 cp", i, file.path(dnames[2], basename(i)))
  system(cmd)
}
gs_urls <- planet_aoi1 %>% filter(season == "GS") %>% distinct(url) %>% 
  unname %>% unlist
for(i in gs_urls) {
  cmd <- paste("aws s3 cp", i, file.path(dnames[1], basename(i)))
  system(cmd)
}

os_tiles <- os %>% select(Key, Size, Bucket) %>% 
  mutate(Size = as.numeric(Size)) %>% 
  filter(Key %in% gsub("s3://activemapper/", "", planet_aoi1$url))
  # with(get_object(object = os$KeyKey, bucket = Bucket, 
  #                 file = file.path(dnames[2], basename(Key))))
get_object(object = os_tiles$Key[1], bucket = os_tiles$Bucket[1], 
           file = file.path(dnames[2], basename(os_tiles$Key[1])))
```

After creating that and manually classifying and adjusting reference category, read in, make duplicate, clear selections, and write out for additional supervisors. 
```{r, eval=FALSE}
ref_aoi1 <- st_read(here::here("external/data/ref_polys_ao1.sqlite"))
# ref_aoi1 %>% ggplot() + geom_histogram(aes(x = cls), stat = "count")
ref_aoi1 %>% mutate(cls = NA) %>% 
  st_write(here::here("external/data/ref_polys_ao1_template.sqlite"))
```

Now read in and assess accuracy. Grab probability images for AOI1
```{r, eval=FALSE}
library(aws.s3)
library(raster)

# create master_grid extent, get list of probability images, download fpool 
# (for checking)
aois <- st_read(here("external/data/aois.geojson"))
mgrid_ext <- raster(extent(-17.541, 51.459, -35.46, 37.54), res = 0.05)
pimgs <- get_bucket_df(bucket = "activemapper", 
                       prefix = "classified-images/1_whole_test") %>% as_tibble
fpool1 <- s3read_using(FUN = readr::read_csv, 
                       object = "planet/f_pool_1.csv", bucket = "activemapper")
host <- "labeller1.crowdmapper.org"
con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), host = host, 
                      dbname = "Africa", user = "postgis", password = pw)
mgrid <- tbl(con, "master_grid") %>% filter(name %in% local(fpool1$name)) %>% 
  collect()
kml_data <- tbl(con, "kml_data") %>% filter(kml_type == "F") %>% collect()
# mgrid %>% st_as_sf(coords = c("x", "y")) %>% st_geometry %>% plot

# strip out row, col from names of probability images, and convert them to x, y
# from dummy master_grid
sstr <- "classified-images/1_whole_test/image_"
pimgs <- pimgs %>% select(Key) %>% 
  mutate(row = gsub("c*.*_r|.tif", "", gsub(sstr, "", Key))) %>% 
  mutate(col = gsub("c|_r*.*.tif", "", gsub(sstr, "", Key))) %>% 
  select(Key, row, col)
pimgs_xy <- bind_cols(pimgs, 
                      x = xFromCol(mgrid_ext, as.numeric(pimgs$col) + 1),
                      y = yFromRow(mgrid_ext, as.numeric(pimgs$row) + 1)) %>%
  st_as_sf(coords = c("x", "y"), crs = 4326)

# use xy to extract tile ids
tiles <- read_sf(here("inst/extdata/ghana_tiles.geojson"))
tiles_xy <- st_intersection(tiles, pimgs_xy)
tiles_xy <- st_intersection(tiles_xy, aois %>% select(aois)) %>% as_tibble() %>%
  select(tile, row, col, aois)
tiles_rc <- inner_join(tiles_xy, tiles %>% select(tile)) %>% st_as_sf() %>% 
  select(aois, tile, row, col)
# ggplot(aois) + geom_sf() + geom_sf(data = tiles_xy) +
#   theme_void()

# select grid cell coordinates for reference cells, and then use those to 
# intersect with tiles to get row, col for probability images
ref_xys <- mgrid %>% filter(name %in% ref_aoi1$name) %>% 
  distinct(id, name, x, y) %>% st_as_sf(coords = c("x", "y"), crs = 4326)
# which(ref_xys$name %in% kml_data$name)  # confirm no reference sites intersect
ref_xys_tiles <- st_intersection(ref_xys, tiles_rc) %>% as_tibble

# Then use to get probability image values
# ref_xys_tiles %>% distinct(row, col)
dup_tiles <- ref_xys_tiles %>% filter(duplicated(tile)) %>% pull(tile)
# ref_xys_tiles %>% filter(tile %in% dup_tiles)
unique_ref_tiles <- ref_xys_tiles %>% distinct(tile) %>% pull %>% sort
ref_pvals <- lapply(unique_ref_tiles, function(x) {  # x <- unique_ref_tiles[6]
  print(x)
  tile <- ref_xys_tiles %>% filter(tile == x) 
  ref <- ref_aoi1 %>% filter(name %in% tile$name)
  prob_tile <- pimgs %>% 
    filter(row == unique(tile$row) & col == unique(tile$col))
  prob_tiler <- raster(paste0("/vsis3/activemapper/", prob_tile$Key))
  pvals <- extract(prob_tiler, ref)
  v <- do.call(rbind, lapply(pvals, function(x) {
    tibble(mu = mean(x), sd = sd(x), n = length(x))
  }))
  bind_cols(ref, v) %>% select(name, rid, cls, mu, sd, n)
})
ref_pvals <- do.call(rbind, ref_pvals)
ref_pvals_tb <- ref_pvals %>% as_tibble
ref_pvals_tb %>% ggplot() + geom_boxplot(aes(x = cls, y = mu))

tp <- ref_pvals_tb %>% filter(cls == "f" & mu > 50) %>% count
fn <- ref_pvals_tb %>% filter(cls == "f" & mu < 50) %>% count
fp <- ref_pvals_tb %>% filter(cls == "n" & mu > 50) %>% count
tn <- ref_pvals_tb %>% filter(cls == "n" & mu < 50) %>% count

# ref_pvals_tb %>% filter(cls == "f" & mu > 40) %>% count
# ref_pvals_tb %>% filter(cls == "n" & mu > 40) %>% count
ref_pvals_tb %>% filter(cls == "n" & mu < 40) %>% count
laref_pvals_tb %>% filter(cls == "u" & between(mu, 30, 70))
ref_pvals_tb %>% filter(cls == "u" & (mu < 30 | mu > 70))

(tp + tn) / (tp + tn + fp + fn)

ref_pvals_tb %>% filter(cls == "n" & mu > 50)

```

## Figure 4: Average quality of image tiles

Placeholder for now, as using imagined image quality.

```{r, eval=FALSE}
# randomly select cells, as if those used to assess image quality
set.seed(1)
tiles_ss <- tiles %>% sample_n(100)

# set up dummy values of quality, using rainfall as example and regression with
# some random noise added
rftiles <- unlist(extract(rftot, tiles_ss))  # rainfall
tiles_ss <- tiles_ss %>% mutate(rf = rftiles) %>% select(aoi, tile, rf)
rflm <- coef(lm(c(8, 1) ~ range(tiles_ss$rf)))  # regression 1 to 8
qual_preds <- rflm[1] + rflm[2] * tiles_ss$rf  # predict
set.seed(7) 
qual_preds <- round(qual_preds *  # random noise
                      runif(length(qual_preds), min = 0.7, max = 1.3))
qual_preds <- ifelse(qual_preds > 5, 5, qual_preds)  # force to 5
tiles_ss <- tiles_ss %>% mutate(Quality = factor(qual_preds)) %>% 
  select(aoi, tile, rf, Quality)

# random assignment of 1-5 by rainfall
p1 <- ggplot(africa) + geom_sf(fill = "gray97", color = "grey", size = 0.25) +
  geom_sf(data = tiles, fill = "grey85", col = "grey", size = 0.3) +
  geom_sf(data = ghana, fill = "transparent", col = "grey", size = 0.3) +
  geom_sf(data = tiles_ss, 
          mapping = aes(fill = Quality, color = Quality)) +   
  scale_fill_brewer(palette = "RdBu") + scale_color_brewer(palette = "RdBu") + 
  coord_sf(xlim = maprange[1:2], ylim = maprange[3:4]) + 
  theme_void()
p2 <- ggplot(tiles_ss) + 
  geom_histogram(aes(x = Quality), bins = 5, stat = "count", col = "grey", 
                 fill = "blue") + 
  xlab("Quality of composite") + ylab("N tiles") + 
  cowplot::theme_cowplot(font_size = 12)
g <- cowplot::plot_grid(p1, p1, p2, p2, nrow = 2, scale = c(1, 1, 0.9), 
                        labels = LETTERS[1:4], label_x = 0.05)
ggsave("manuscript/figures/figure4.png", width = 5, height = 5, 
       units = "in", dpi = 300)
```

### Accuracy within blocks

Placeholder. Use imagined accuracy based on rainfall, using dummy approach as with Figure 3.  This will be replaced by metrics from tables for each instance. 
```{r, eval=FALSE}
rf <- aois %>% st_centroid %>% extract(rftot, .)
aois <- aois %>% mutate(rf = rf)

# Rainfall-accuracy relationship
rflm <- coef(lm(c(0.9, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(7) 
aois <- aois %>% 
  mutate(Accuracy = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100)

# Users
rflm <- coef(lm(c(0.85, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(1) 
aois <- aois %>% 
  mutate(User = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100)

# Producers
rflm <- coef(lm(c(0.9, 0.75) ~ range(aois$rf)))  # 75-90%
set.seed(2) 
aois <- aois %>% 
  mutate(Producer = (rflm[1] + rflm[2] * rf) * 
           runif(n(), min = 0.95, max = 1.05) * 100) %>% 
  select(grp, aois, rf, Accuracy, User, Producer)

```

## Figure 5

Plot of Zones and average accuracy
```{r, eval = FALSE}
# ghana_tilesr %>% group_by(aoi) %>% summarize(aois = mean(aoi)) %>% ungroup %>% 
#   ggplot() + geom_sf(col = "grey70") +
#   geom_sf_text(aes(label = aoi), size = 2) + 
#   geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + 
#   theme_void()

cols <- RColorBrewer::brewer.pal(n = 9, "RdYlGn") %>% #[c(1, 9)] %>% 
  colorRampPalette(colors = .)
# RColorBrewer::display.brewer.all()

# ggsave("manuscript/figures/si_mapping_blocks.png", width = 5, height = 5, 
#        units = "in", dpi = 300)

col_grad <- scale_fill_gradientn(colors = cols(10), limits = c(70, 100), 
                                 breaks = seq(70, 100, 5)) 
p <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = Accuracy)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()
p2 <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = User)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()
p3 <- map_blocks %>% 
  ggplot() + geom_sf(aes(fill = Producer)) + #, col = "grey70") +
  geom_sf_text(aes(label = grp), size = 2) + 
  geom_sf(data = ghana, fill = "transparent", lwd = 0.3) + col_grad + 
  theme_void()

leg <- cowplot::get_legend(p + theme(legend.position = c(0.6, 1)))
gleg <- cowplot::plot_grid(NULL, leg, ncol = 1, align = "h")
gp <- cowplot::plot_grid(p + theme(legend.position = 'none'), 
                         p2 + theme(legend.position = 'none'), 
                         p3 + theme(legend.position = 'none'), nrow = 1, 
                         labels = c("Overall", "User's", "Producer's"), 
                         label_x = 0.0)
gall <- cowplot::plot_grid(gp, gleg, rel_widths = c(1, 0.1), label_x = 0)
# gall

ggsave("manuscript/figures/figure5.png", width = 9, 
       height = 4, units = "in", dpi = 300)

```

## Figure 6: High, low, medium comparisons

Statistics from high, medium, low experiment results from Boka. 
```{r, eval = FALSE}
library(tidyr)
library(dplyr)
library(ggplot2)
library(cowplot)

# metrics
scores <- tibble(
  # AOI = as.character(c(rep(1, 3), rep(8, 3), rep(15, 3))), 
  AOI = c(rep(1, 3), rep(8, 3), rep(15, 3)), 
  Label = c("Low", "High", "Consensus", "Low", "High", "Consensus", 
            "Low", "High", "Consensus"), 
  AUC = c(0.6987, 0.7803, 0.7741, 0.7333, 0.8461, 0.8563, 0.6916, 0.7628, 
          0.7714),
  Accuracy = c(0.6575, 0.7919, 0.7897, 0.5313, 0.8361, 0.8421, 0.6279, 0.6916,
               0.7245),
  TSS = c(0.2940, 0.4194, 0.4138, 0.2568, 0.5390, 0.5639, 0.2718, 0.3835, 
          0.3916)
)
p <- scores %>% pivot_longer(cols = c("AUC", "Accuracy", "TSS")) %>% 
  arrange(AOI) %>%
  group_by(AOI) %>% 
  ggplot(.) + geom_bar(aes(x = name, y = value, fill = Label), 
                       stat = "identity", position = "dodge") + 
  scale_fill_manual(values = c("blue", "purple", "orange"), 
                    name = "Labelling strategy", 
                    labels = c("Consensus", "Highest scorer", 
                               "Lowest scorer")) + 
  xlab("Metric") + ylab("Score") + ggtitle("AOI") +
  facet_grid(. ~ AOI) + theme_cowplot() 
ggsave(p, 
       filename = here::here("manuscript/figures/figure6.png"),
       height = 4, width = 8, dpi = 300)
save(scores, file = here::here("external/data/label_experiment_metrics.rda"))
```

### Figure SX: SI probability images
```{r, eval=FALSE}
library(raster)
probpal <- viridis::viridis
cprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "1_whole/image_c294_r532.tif"))
hprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "test_byScore/aoi1/high/image_c294_r532.tif"))
lprob <- raster(glue::glue("/vsis3/activemapper/classified-images/", 
                           "test_byScore/aoi1/low/image_c294_r532.tif"))
png(here::here("manuscript/figures/si_hml_probs.png"), height = 2.65,
    width = 9.2, res = 300, units = "in", bg = "transparent")
par(mfrow = c(1, 3), mar = c(0, 0, 0, 1), oma = c(0, 0, 0, 2))
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Consensus labels", 
     cex.main = 2)
plot(cprob, lty = 0, add = TRUE, legend = FALSE, zlim = c(0, 100),
     col = probpal(20))
mtext("A", side = 3, line = -2, adj = 0.00)
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Highest scorer", 
     cex.main = 2)
mtext("B", side = 3, line = -2, adj = 0.0)
plot(hprob, lty = 0, add = TRUE, legend = FALSE, zlim = c(0, 100),
     col = probpal(20))
plot(as(extent(cprob), "SpatialPolygons"), lty = 0, #main = "Lowest scorer", 
     cex.main = 2)
mtext("C", side = 3, line = -2, adj = 0.0)
plot(lprob, lty = 0, add = TRUE, zlim = c(0, 100),
     legend.width = 1, legend.shrink = 0.5, col = probpal(20),
     legend.args = list(text = '%', side = 3, cex = 0.8))
dev.off()

```


## Consensus maps
```{r, eval=FALSE}
library(rmapaccuracy)
library(leaflet)

instance <- "mapper0"
dbase <- "Africa"
host <- paste0(instance, ".crowdmapper.org")
upw <- list("user" = "postgis", "password" = "P0stG1S")
coninfo <- mapper_connect(host)
con <- DBI::dbConnect(RPostgreSQL::PostgreSQL(), host = host,
                      dbname = "Africa", user = upw$user,
                      password = upw$password)

# coninfo <- mapper_connect(host = host)
coninfo$con <- con

common_path <- "~/Dropbox/projects/activelearning/mapper"
common_path <- file.path(common_path, "common")
params <- yaml::yaml.load_file(file.path(common_path, 'config.yaml'))

name <- "GH0431618"#"GH0448854"
sqls <- paste0("select id from master_grid where name='", name, "'")
cid <- DBI::dbGetQuery(con, sqls)[[1]]


user.sql <- paste0("select name, category, worker_id, geom_clean ",
                   "FROM user_maps INNER JOIN categories USING (category)",
                   "INNER JOIN assignment_data USING (assignment_id)",
                   " where name like '",  name, "%' ",
                   "AND categ_group ='field'")

user.polys <- DBI::dbGetQuery(con, gsub(", geom_clean", "", user.sql))
user.polys <- suppressWarnings(st_read(con, query = user.sql))
user.polys <- user.polys %>% filter(st_is(. , "POLYGON"))

# # calling consensus map manually, line by line in script
kmlid <- name
qsite <- FALSE
mode <- "consensus"

# execute consensus script
source(file.path(here::here(), "external/scripts/consensus_labels.R"))
l <- list(user.polys["worker_id"], bayesoutput[[2]], bayesoutput[[1]])
save(l, file = file.path(here::here(), "data/consensus.rda"))

scenes <- tbl(con, "scenes_data") %>% filter(cell_id == cid) %>% 
  dplyr::select(scene_id, cell_id, url, season, tms_url) %>% collect()
# scenes$scene_id

gcs <- "+proj=longlat +datum=WGS84 +no_defs"
name <- tbl(coninfo$con, "master_grid") %>% filter(id == cid) %>%
  dplyr::select(id, name, x, y) %>% collect()
gpoly <- rmapaccuracy::point_to_gridpoly(data.table::data.table(name), 
                                         w = 0.005 / 2, gcs, gcs)

s3url <- scenes %>% filter(season == "GS") %>% pull(url)
planet_path <- file.path("/vsis3", gsub("s3://", "", s3url)) 
planet <- brick(planet_path)

crfeat <- as(extend(extent(as_Spatial(ejura_sites[1, ])), 0.005),
             "SpatialPolygons")
zoomfeat <- as(extend(extent(as_Spatial(ejura_sites[1, ])), 0.002),
               "SpatialPolygons")
proj4string(crfeat) <- proj4string(as_Spatial(user.polys))
proj4string(zoomfeat) <- proj4string(as_Spatial(user.polys))
crfeat_utm <- spTransform(crfeat, crs(planet))
zoomfeat_utm <- spTransform(zoomfeat, crs(planet))
planet_cr <- crop(planet, crfeat_utm)
planet_cr2 <- crop(planet2, crfeat_utm)



# set up display
os <- (scenes %>% filter(season == "OS") %>% filter(row_number() == 1) %>% 
  dplyr::select(tms_url))$tms_url
gs <- (scenes %>% filter(season == "GS") %>% filter(row_number() == 1) %>% 
         dplyr::select(tms_url))$tms_url

m <- leaflet() %>% addTiles() %>% setView(name$x, name$y, zoom = 14) %>% 
  addTiles(os, group = "OS") %>% addTiles(gs, group = "GS") %>% 
  addPolygons(data = gpoly, fill = FALSE, group = "Cell") %>% 
  addLayersControl(overlayGroups = c("Cell", "GS", "OS"),
    options = layersControlOptions(collapsed = FALSE, autoZIndex = FALSE))
m


```

